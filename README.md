# 次元文本整理术 - 聊天记录清理 WebUI ✨

一个简单易用的 Web 小工具，可以帮你快速清理使用QQ Chat Exporter Pro导出的QQ聊天记录 TXT 文件，去除影响AI分析的时间戳和媒体文件路径。拥有现代化的毛玻璃和辉光效果 UI！

此程序使用了Gemini2.5Pro来编写，为AI制作。

## 主要功能 🌟

*   **网页用户界面 (WebUI):** 无需命令行操作，界面友好。
*   **文件上传:** 支持拖拽 TXT 文件或点击选择文件。
*   **路径清理:** 自动移除文本中 `[图片] 路径: ...` 和 `[视频] 路径: ...` 后缀。
*   **时间戳清理 (可选):** 提供滑动开关，自由选择是否移除每行开头的数字时间戳及其后的空白。
*   **现代化 UI:** 采用毛玻璃背景和元素辉光效果，视觉舒适。
*   **结果下载:** 清理后的文本内容直接以 `cleaned_原文件名.txt` 的形式下载到浏览器。

## 使用说明 🚀

**环境要求:**

*   Python 3.7 或更高版本
*   pip (Python 包管理器, 通常随 Python 安装)

**步骤:**

1.  **克隆或下载仓库:**
    ```bash
    git clone <你的仓库 Git 地址>
    cd <仓库目录>
    ```
    或者直接下载 ZIP 压缩包并解压。

2.  **安装依赖:**
    只需要 Flask 框架。在项目目录下打开终端或命令提示符，运行：
    ```bash
    pip install Flask
    ```

3.  **运行应用:**
    在同一终端窗口中运行 Python 脚本：
    ```bash
    python app.py
    ```

4.  **访问 Web 界面:**
    脚本运行后，终端会显示类似 `* Running on http://127.0.0.1:5000/` (或 `http://0.0.0.0:5000/`) 的信息。
    打开你的网页浏览器 (如 Chrome, Firefox, Edge 等)，访问显示的地址，通常是：
    ➡️ `http://127.0.0.1:5000/`

5.  **使用工具:**
    *   将你的 `.txt` 聊天记录文件**拖拽**到网页中间的虚线区域，或者**点击**该区域选择文件。
    *   文件选择后，下方会显示文件名，并且**“清理并下载”**按钮会亮起（变为可用）。
    *   在按钮上方有一个**滑动开关**，你可以用它来决定**是否要移除**每行开头的时间戳数字。开关默认为开启（移除时间戳）。
    *   点击**“清理并下载”**按钮。
    *   浏览器会自动开始下载处理后的文件，文件名通常是 `cleaned_你的原始文件名.txt`。

## 简单的原理 💡

这个小工具主要由以下几部分构成：

1.  **后端 (Python + Flask):**
    *   使用 **Flask** 这个轻量级 Web 框架来搭建服务器。
    *   定义了两个主要路由 (`@app.route`):
        *   `/` (GET): 显示主网页界面 (HTML)。
        *   `/process` (POST):接收用户通过表单上传的文件和选项。
    *   **文件处理:**
        *   通过 `request.files['inputFile']` 获取上传的文件对象。
        *   尝试使用 `utf-8` 编码读取文件内容，如果失败则回退尝试 `gbk` 编码（兼容常见的 Windows 中文环境编码）。
        *   读取 `request.form` 来判断“移除时间戳”开关的状态。
    *   **核心清理逻辑 (Python 函数 `clean_text_content`):**
        *   接收文本内容和是否移除时间戳的标志。
        *   **时间戳移除 (可选):** 如果标志为 True，使用正则表达式 `re.sub(r"^\d+\s+", '', line)` 查找并替换行首的一个或多个数字 (`\d+`) 及紧随其后的一个或多个空白字符 (`\s+`)。
        *   **路径移除:** 使用字符串的 `find()` 方法分别查找 `[图片] 路径:` 和 `[视频] 路径:` 在（可能已移除时间戳的）行中的位置。如果两者都存在，取 `min()` 得到最先出现的位置；如果只存在一个，则取那个位置；如果都不存在，则标记为 -1。
        *   根据找到的位置进行字符串**切片** (`line[:index]`)，只保留标记之前的部分。使用 `rstrip()` 去除切片后末尾可能残留的空白。
        *   将处理后的每一行（包括原本就是空行的情况）收集起来。
    *   **响应生成:** 将处理后的所有行用换行符 (`\n`) 重新组合成一个字符串，并使用 Flask 的 `Response` 对象将其包装成一个 `text/plain` 类型的文件下载响应，通过设置 `Content-Disposition` 头指定下载的文件名。
    *   **错误处理:** 使用 `flash` 消息向用户反馈错误（如未选择文件、文件类型错误、解码失败等），并通过 `redirect` 将用户导回首页。使用 `try...except` 捕获处理过程中的异常。

2.  **前端 (HTML + CSS + JavaScript):**
    *   **HTML:** 构建网页的基本结构，包括标题、描述、文件上传区域 (`div.upload-area` 内含隐藏的 `<input type="file">`)、选项开关 (基于 `<input type="checkbox">` 和 `label/span` 实现视觉效果) 以及提交按钮 (`<button>`)，所有这些都包含在一个 `<form>` 中。
    *   **CSS:** 负责页面的外观和美化。
        *   布局 (Flexbox)。
        *   毛玻璃效果 (`background-color` 半透明 + `backdrop-filter: blur(...)`)。
        *   滑动开关的视觉样式和动画 (`.switch`, `.slider`, `:checked` 伪类)。
        *   按钮和开关的辉光效果 (`box-shadow` 应用于 `:hover` 或 `:focus` 状态)。
        *   过渡动画 (`transition`) 使效果更平滑。
        *   响应式设计的基本考虑 (`max-width`, `width: 95%`)。
    *   **JavaScript:** 处理用户交互，提升体验。
        *   **文件选择/拖拽:** 监听 `drop`, `dragover` 等事件实现文件拖拽上传。监听 `<input type="file">` 的 `change` 事件处理点击选择。
        *   **文件校验:** 基础的客户端文件类型检查 (仅 `.txt`)。
        *   **UI 更新:** 在选择/拖拽文件后，使用 JS 更新界面显示文件名 (`#file-info`)，并根据文件是否有效来**启用/禁用**提交按钮 (`submitBtn.disabled`)。
        *   **文件关联:** 使用 `DataTransfer` 对象将用户选择或拖拽的文件**关联**到隐藏的 `<input type="file">` 元素上，确保表单提交时文件能被发送到后端。
        *   **标签点击:** 使开关旁边的文字标签也能触发开关状态的改变。
