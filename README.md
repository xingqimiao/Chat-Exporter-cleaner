# 次元文本整理术 - 聊天记录清理 WebUI ✨

一个简单易用的 Web 小工具，可以帮你快速清理使用QQ Chat Exporter Pro导出的QQ聊天记录json 文件，去除影响AI分析的时间戳和媒体文件路径转为工整带时间的txt。拥有现代化的毛玻璃和辉光效果 UI！

此程序使用了Gemini2.5Pro来编写，为AI制作。

## 主要功能 🌟

*   **网页用户界面 (WebUI):** 无需命令行操作，界面友好。
*   **文件上传:** 支持拖拽 json 文件或点击选择文件。
*   **路径清理:** 自动移除文本中 `[图片] 路径: ...` 和 `[视频] 路径: ...` 后缀。
*   **现代化 UI:** 采用毛玻璃背景和元素辉光效果，视觉舒适。
*   **结果下载:** 清理后的文本内容直接以 `原文件名_formatted.txt` 的形式下载到浏览器。

## 使用说明 🚀

**环境要求:**

*   Python 3.7 或更高版本
*   pip (Python 包管理器, 通常随 Python 安装)

**步骤:**

1.  **下载Releases:**

    直接下载 ZIP 压缩包并解压。

2.  **安装依赖:**
    只需要 Flask 框架。运行flask安装脚本.bat即可

3.  **运行应用:**
    在终端窗口中运行 Python 脚本：
    运行run.bat

4.  **访问 Web 界面:**
    脚本运行后，终端会显示类似 `* Running on http://127.0.0.1:5000/` (或 `http://0.0.0.0:5000/`) 的信息。
    打开你的网页浏览器 (如 Chrome, Firefox, Edge 等)，访问显示的地址，通常是：
    ➡️ `http://127.0.0.1:5000/`

5.  **使用工具:**
    *   将你的 `.json` 聊天记录文件**拖拽**到网页中间的虚线区域，或者**点击**该区域选择文件。
    *   文件选择后，下方会显示文件名，并且**“清理并下载”**按钮会亮起（变为可用）。
    *   在按钮上方有一个**滑动开关**，你可以用它来决定**是否要移除**每行开头的时间戳数字。开关默认为开启（移除时间戳）。
    *   点击**“清理并下载”**按钮。
    *   浏览器会自动开始下载处理后的文件，文件名通常是 `你的原始文件名_formatted.txt`。

## 简单的原理 💡

（v1.0重写）
核心流程如下：
启动服务器 (后端):
    当你运行 python app.py 时，会启动一个基于 Flask 的轻量级 Web 服务器。
    Flask 负责监听指定的网络端口（默认为 5000），等待来自浏览器的 HTTP 请求。
用户访问页面 (前端):
    用户在浏览器中访问服务器地址（例如 http://127.0.0.1:5000）。
    Flask 后端接收到根路径 / 的 GET 请求，并返回一个包含完整 HTML、CSS 和 JavaScript 代码的响应。
浏览器渲染界面 (前端):
    浏览器解析收到的 HTML，构建页面结构（标题、拖拽框、按钮、状态显示区域等）。
    浏览器应用 CSS 规则，为页面元素添加样式（布局、颜色、阴影、浅蓝色背景、按钮的圆角和辉光/果冻效果等）。
    浏览器执行内嵌的 JavaScript 代码。
JavaScript 交互 (前端):
    DOM 加载: JavaScript 首先等待整个 HTML 页面（DOM）加载完成 (使用 DOMContentLoaded 事件)。
    事件监听: JavaScript 为关键元素（拖拽框、隐藏的文件输入框、格式化按钮）绑定事件监听器。
    拖拽框 (#drop-zone): 监听 click（触发文件选择）、dragenter, dragover, dragleave, drop 事件，实现文件的拖放上传功能。拖拽悬停时会有视觉反馈（边框、背景、阴影变化）。
    文件输入框 (#file-input): 监听 change 事件，当用户通过点击选择文件后触发。
    格式化按钮 (#format-button): 监听 click 事件。按钮初始为禁用状态，当用户成功选择了一个有效的 JSON 文件后，JavaScript 会启用该按钮。按钮有 hover (柔光效果) 和 active (果冻动画) 的 CSS 效果。
    件处理: 当用户选择或拖放文件后，JavaScript 会检查文件是否为 JSON 类型（通过 type 属性或 .json 后缀名判断）。如果有效，则记录该文件，并更新界面显示已选文件名。
    发起请求: 当用户点击“格式化”按钮时：
    JavaScript 获取选中的文件。
    使用 FormData 对象封装文件数据。
    通过 fetch API 向后端的 /format 路径发送一个 POST 请求，并将文件数据作为请求体发送。
    同时，禁用按钮并显示“正在处理...”的状态。
服务器处理请求 (后端):
    Flask 后端接收到 /format 的 POST 请求。
    文件获取: 从请求中提取上传的文件 (request.files['jsonFile'])。
    验证: 检查文件是否存在、文件名是否有效、文件类型是否符合要求。
    读取与解析:
    使用 file.stream.read().decode('utf-8') 读取文件内容。
    使用 Python 内置的 json.loads() 将 JSON 文本解析成 Python 数据结构（预期是一个包含多个字典的列表）。
    核心格式化: 调用 format_chat_log(data) 函数：
    该函数遍历解析后的消息列表。
    对每条消息，提取 timestamp, sender, content 字段。
    使用 datetime 模块解析和格式化时间戳 (ISO 8601 -> YYYY-MM-DDTHH:MM:SS)。
    使用 re (正则表达式) 模块清理 content，将图片/视频的路径信息替换为简单的 [图片] 或 [视频] 标签。
    将格式化后的时间、发送者、内容拼接成指定的文本行格式。
    最终将所有格式化后的行用换行符合并成一个大的字符串。
    错误处理: 在读取、解析、格式化过程中使用 try...except 捕获可能发生的错误（如无效 JSON、编码错误、缺少关键字段等），并准备合适的错误信息。
服务器发送响应 (后端):
    成功:
将格式化后的文本字符串编码为 UTF-8 字节流。
使用 io.BytesIO 创建一个内存中的二进制文件对象。
调用 Flask 的 send_file 函数，将这个内存文件作为响应发送回浏览器。
send_file 会设置必要的 HTTP 响应头：
Content-Type: text/plain; charset=utf-8 告诉浏览器这是一个 UTF-8 编码的纯文本文件。
Content-Disposition: attachment; filename="..." 提示浏览器将响应作为附件下载，并建议下载的文件名（基于原始文件名加上 _formatted.txt）。
    失败:
返回一个 JSON 格式的错误响应 (jsonify({"error": "错误信息"}))，并设置相应的 HTTP 状态码（如 400 Bad Request, 500 Internal Server Error）。
浏览器处理响应 (前端):
JavaScript 的 fetch 调用接收到服务器的响应。
    成功:
检查响应状态码是否表示成功 (e.g., response.ok)。
将响应体读取为 Blob 对象。
使用 window.URL.createObjectURL(blob) 创建一个指向该 Blob 的临时 URL。
动态创建一个隐藏的 <a> (链接) 元素，设置其 href 为临时 URL，download 属性为服务器建议的文件名。
模拟点击这个链接 (a.click())，触发浏览器的文件下载。
下载完成后，释放临时 URL (window.URL.revokeObjectURL(url)) 并移除 <a> 元素。
更新状态栏显示成功信息。
    失败:
读取服务器返回的 JSON 错误信息。
更新状态栏显示错误详情。
最终: 无论成功或失败，重新启用格式化按钮。


（v0.9）
这个小工具主要由以下几部分构成：
1.  **后端 (Python + Flask):**
    *   使用 **Flask** 这个轻量级 Web 框架来搭建服务器。
    *   定义了两个主要路由 (`@app.route`):
        *   `/` (GET): 显示主网页界面 (HTML)。
        *   `/process` (POST):接收用户通过表单上传的文件和选项。
    *   **文件处理:**
        *   通过 `request.files['inputFile']` 获取上传的文件对象。
        *   尝试使用 `utf-8` 编码读取文件内容，如果失败则回退尝试 `gbk` 编码（兼容常见的 Windows 中文环境编码）。
        *   读取 `request.form` 来判断“移除时间戳”开关的状态。
    *   **核心清理逻辑 (Python 函数 `clean_text_content`):**
        *   接收文本内容和是否移除时间戳的标志。
        *   **时间戳移除 (可选):** 如果标志为 True，使用正则表达式 `re.sub(r"^\d+\s+", '', line)` 查找并替换行首的一个或多个数字 (`\d+`) 及紧随其后的一个或多个空白字符 (`\s+`)。
        *   **路径移除:** 使用字符串的 `find()` 方法分别查找 `[图片] 路径:` 和 `[视频] 路径:` 在（可能已移除时间戳的）行中的位置。如果两者都存在，取 `min()` 得到最先出现的位置；如果只存在一个，则取那个位置；如果都不存在，则标记为 -1。
        *   根据找到的位置进行字符串**切片** (`line[:index]`)，只保留标记之前的部分。使用 `rstrip()` 去除切片后末尾可能残留的空白。
        *   将处理后的每一行（包括原本就是空行的情况）收集起来。
    *   **响应生成:** 将处理后的所有行用换行符 (`\n`) 重新组合成一个字符串，并使用 Flask 的 `Response` 对象将其包装成一个 `text/plain` 类型的文件下载响应，通过设置 `Content-Disposition` 头指定下载的文件名。
    *   **错误处理:** 使用 `flash` 消息向用户反馈错误（如未选择文件、文件类型错误、解码失败等），并通过 `redirect` 将用户导回首页。使用 `try...except` 捕获处理过程中的异常。

2.  **前端 (HTML + CSS + JavaScript):**
    *   **HTML:** 构建网页的基本结构，包括标题、描述、文件上传区域 (`div.upload-area` 内含隐藏的 `<input type="file">`)、选项开关 (基于 `<input type="checkbox">` 和 `label/span` 实现视觉效果) 以及提交按钮 (`<button>`)，所有这些都包含在一个 `<form>` 中。
    *   **CSS:** 负责页面的外观和美化。
        *   布局 (Flexbox)。
        *   毛玻璃效果 (`background-color` 半透明 + `backdrop-filter: blur(...)`)。
        *   滑动开关的视觉样式和动画 (`.switch`, `.slider`, `:checked` 伪类)。
        *   按钮和开关的辉光效果 (`box-shadow` 应用于 `:hover` 或 `:focus` 状态)。
        *   过渡动画 (`transition`) 使效果更平滑。
        *   响应式设计的基本考虑 (`max-width`, `width: 95%`)。
    *   **JavaScript:** 处理用户交互，提升体验。
        *   **文件选择/拖拽:** 监听 `drop`, `dragover` 等事件实现文件拖拽上传。监听 `<input type="file">` 的 `change` 事件处理点击选择。
        *   **文件校验:** 基础的客户端文件类型检查 (仅 `.txt`)。
        *   **UI 更新:** 在选择/拖拽文件后，使用 JS 更新界面显示文件名 (`#file-info`)，并根据文件是否有效来**启用/禁用**提交按钮 (`submitBtn.disabled`)。
        *   **文件关联:** 使用 `DataTransfer` 对象将用户选择或拖拽的文件**关联**到隐藏的 `<input type="file">` 元素上，确保表单提交时文件能被发送到后端。
        *   **标签点击:** 使开关旁边的文字标签也能触发开关状态的改变。
