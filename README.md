# 次元文本整理术 - 聊天记录清理 WebUI ✨

一个简单易用的 Web 小工具，可以帮你快速清理使用QQ Chat Exporter Pro导出的QQ聊天记录json 文件，去除影响AI分析的时间戳和媒体文件路径转为工整带时间的txt。拥有现代化的毛玻璃和辉光效果 UI！

此程序使用了Gemini2.5Pro来编写，为AI制作。

## 主要功能 🌟

*   **网页用户界面 (WebUI):** 无需命令行操作，界面友好。
*   **文件上传:** 支持拖拽 json 文件或点击选择文件。
*   **路径清理:** 自动移除文本中 `[图片] 路径: ...` 和 `[视频] 路径: ...` 后缀。
*   **现代化 UI:** 采用毛玻璃背景和元素辉光效果，视觉舒适。
*   **结果下载:** 清理后的文本内容直接以 `原文件名_formatted.txt` 的形式下载到浏览器。

## 使用说明 🚀

**环境要求:**

*   Python 3.7 或更高版本
*   pip (Python 包管理器, 通常随 Python 安装)

**步骤:**

1.  **下载Releases:**

    直接下载 ZIP 压缩包并解压。

2.  **安装依赖:**
    只需要 Flask 框架。运行flask安装脚本.bat即可

3.  **运行应用:**
    在终端窗口中运行 Python 脚本：
    运行run.bat

4.  **访问 Web 界面:**
    脚本运行后，终端会显示类似 `* Running on http://127.0.0.1:5000/` (或 `http://0.0.0.0:5000/`) 的信息。
    打开你的网页浏览器 (如 Chrome, Firefox, Edge 等)，访问显示的地址，通常是：
    ➡️ `http://127.0.0.1:5000/`

5.  **使用工具:**
    *   将你的 `.json` 聊天记录文件**拖拽**到网页中间的虚线区域，或者**点击**该区域选择文件。
    *   文件选择后，下方会显示文件名，并且**“清理并下载”**按钮会亮起（变为可用）。
    *   在按钮上方有一个**滑动开关**，你可以用它来决定**是否要移除**每行开头的时间戳数字。开关默认为开启（移除时间戳）。
    *   点击**“清理并下载”**按钮。
    *   浏览器会自动开始下载处理后的文件，文件名通常是 `你的原始文件名_formatted.txt`。

## 简单的原理 💡

（v1.0重写）

**核心流程如下：**

1.  **启动服务器 (后端)**
    *   运行 `python app.py` 时，会启动一个基于 **Flask** 的轻量级 Web 服务器。
    *   Flask 负责监听指定的网络端口（默认为 `5000`），等待来自浏览器的 HTTP 请求。

2.  **用户访问页面 (前端)**
    *   用户在浏览器中访问服务器地址（例如 `http://127.0.0.1:5000`）。
    *   Flask 后端接收到根路径 `/` 的 `GET` 请求，并返回一个包含完整 `HTML`、`CSS` 和 `JavaScript` 代码的响应。

3.  **浏览器渲染界面 (前端)**
    *   浏览器解析收到的 `HTML`，构建页面结构（标题、拖拽框、按钮、状态显示区域等）。
    *   浏览器应用 `CSS` 规则，为页面元素添加样式（布局、颜色、阴影、浅蓝色背景、按钮的圆角和辉光/果冻效果等）。
    *   浏览器执行内嵌的 `JavaScript` 代码。

4.  **JavaScript 交互 (前端)**
    *   **DOM 加载:** JavaScript 等待整个 HTML 页面（DOM）加载完成 (使用 `DOMContentLoaded` 事件)。
    *   **事件监听:** JavaScript 为关键元素绑定事件监听器：
        *   **拖拽框 (`#drop-zone`):** 监听 `click`（触发文件选择）、`dragenter`, `dragover`, `dragleave`, `drop` 事件，实现文件的拖放上传。界面会提供视觉反馈。
        *   **文件输入框 (`#file-input`):** 监听 `change` 事件，处理用户通过点击选择文件的操作。
        *   **格式化按钮 (`#format-button`):** 监听 `click` 事件。按钮状态（启用/禁用）由 JavaScript 根据文件选择状态动态管理。CSS 负责 `hover` (柔光) 和 `active` (果冻) 效果。
    *   **文件处理:** 用户选择或拖放文件后，JavaScript 验证文件类型 (`.json` 或 `application/json`)。有效则记录文件，更新界面。
    *   **发起请求:** 点击“格式化”按钮时：
        *   JavaScript 获取选中的文件。
        *   使用 `FormData` 对象封装文件。
        *   通过 `fetch` API 向后端的 `/format` 路径发送一个 **`POST`** 请求，包含文件数据。
        *   禁用按钮并显示处理状态。

5.  **服务器处理请求 (后端)**
    *   Flask 后端接收到 `/format` 的 `POST` 请求。
    *   **文件获取:** 从请求中提取上传的文件 (`request.files['jsonFile']`)。
    *   **验证:** 检查文件有效性（存在性、文件名、类型）。
    *   **读取与解析:**
        *   使用 `file.stream.read().decode('utf-8')` 读取文件内容。
        *   使用 Python 内置的 `json.loads()` 将 JSON 文本解析成 Python 数据结构（预期为 `list` of `dict`）。
    *   **核心格式化 (调用 `format_chat_log(data)` 函数):**
        *   遍历消息列表。
        *   提取 `timestamp`, `sender`, `content`。
        *   使用 `datetime` 模块格式化时间戳 (`ISO 8601` -> `YYYY-MM-DDTHH:MM:SS`)。
        *   使用 `re` (正则表达式) 清理 `content`，替换图片/视频路径为 `[图片]` / `[视频]` 标签。
        *   拼接成 `时间\n发送人：内容` 格式的文本行。
        *   合并所有行为一个字符串。
    *   **错误处理:** 使用 `try...except` 捕获处理过程中的异常（如 `JSONDecodeError`, `UnicodeDecodeError`, `KeyError` 等），准备错误信息。

6.  **服务器发送响应 (后端)**
    *   **成功:**
        *   将格式化后的文本编码为 `UTF-8` 字节流。
        *   使用 `io.BytesIO` 创建内存中的二进制文件对象。
        *   调用 Flask 的 `send_file` 函数发送响应。
        *   `send_file` 设置响应头：
            *   `Content-Type: text/plain; charset=utf-8`
            *   `Content-Disposition: attachment; filename="..."` (提示下载并建议文件名)
    *   **失败:**
        *   返回 JSON 格式的错误响应 (`jsonify({"error": "错误信息"})`) 和相应的 HTTP 状态码 (如 `400`, `500`)。

7.  **浏览器处理响应 (前端)**
    *   JavaScript 的 `fetch` 接收服务器响应。
    *   **成功:**
        *   检查响应状态 (`response.ok`)。
        *   读取响应体为 `Blob` 对象。
        *   使用 `window.URL.createObjectURL(blob)` 创建临时 URL。
        *   动态创建隐藏的 `<a>` 链接，设置 `href` 和 `download` 属性。
        *   模拟点击 (`a.click()`) 触发下载。
        *   清理临时 URL (`window.URL.revokeObjectURL(url)`) 和 `<a>` 元素。
        *   更新状态栏为成功信息。
    *   **失败:**
        *   读取服务器返回的 JSON 错误信息。
        *   更新状态栏显示错误详情。
    *   **最终:** 无论成功或失败，重新根据文件选择状态启用或禁用格式化按钮。

---

**总结:**

该程序利用 **Flask** 作为后端引擎处理核心逻辑，结合 **HTML5**, **CSS3** 和 **JavaScript (ES6+)** 构建动态、友好的用户界面。通过 **HTTP** 协议在前后端之间交换数据（主要是用户上传的文件和服务器处理后的结果），最终实现了 JSON 到 TXT 的转换和自动下载。其 **单文件集成** 的特点极大地简化了部署和使用流程。


（v0.9）
这个小工具主要由以下几部分构成：
1.  **后端 (Python + Flask):**
    *   使用 **Flask** 这个轻量级 Web 框架来搭建服务器。
    *   定义了两个主要路由 (`@app.route`):
        *   `/` (GET): 显示主网页界面 (HTML)。
        *   `/process` (POST):接收用户通过表单上传的文件和选项。
    *   **文件处理:**
        *   通过 `request.files['inputFile']` 获取上传的文件对象。
        *   尝试使用 `utf-8` 编码读取文件内容，如果失败则回退尝试 `gbk` 编码（兼容常见的 Windows 中文环境编码）。
        *   读取 `request.form` 来判断“移除时间戳”开关的状态。
    *   **核心清理逻辑 (Python 函数 `clean_text_content`):**
        *   接收文本内容和是否移除时间戳的标志。
        *   **时间戳移除 (可选):** 如果标志为 True，使用正则表达式 `re.sub(r"^\d+\s+", '', line)` 查找并替换行首的一个或多个数字 (`\d+`) 及紧随其后的一个或多个空白字符 (`\s+`)。
        *   **路径移除:** 使用字符串的 `find()` 方法分别查找 `[图片] 路径:` 和 `[视频] 路径:` 在（可能已移除时间戳的）行中的位置。如果两者都存在，取 `min()` 得到最先出现的位置；如果只存在一个，则取那个位置；如果都不存在，则标记为 -1。
        *   根据找到的位置进行字符串**切片** (`line[:index]`)，只保留标记之前的部分。使用 `rstrip()` 去除切片后末尾可能残留的空白。
        *   将处理后的每一行（包括原本就是空行的情况）收集起来。
    *   **响应生成:** 将处理后的所有行用换行符 (`\n`) 重新组合成一个字符串，并使用 Flask 的 `Response` 对象将其包装成一个 `text/plain` 类型的文件下载响应，通过设置 `Content-Disposition` 头指定下载的文件名。
    *   **错误处理:** 使用 `flash` 消息向用户反馈错误（如未选择文件、文件类型错误、解码失败等），并通过 `redirect` 将用户导回首页。使用 `try...except` 捕获处理过程中的异常。

2.  **前端 (HTML + CSS + JavaScript):**
    *   **HTML:** 构建网页的基本结构，包括标题、描述、文件上传区域 (`div.upload-area` 内含隐藏的 `<input type="file">`)、选项开关 (基于 `<input type="checkbox">` 和 `label/span` 实现视觉效果) 以及提交按钮 (`<button>`)，所有这些都包含在一个 `<form>` 中。
    *   **CSS:** 负责页面的外观和美化。
        *   布局 (Flexbox)。
        *   毛玻璃效果 (`background-color` 半透明 + `backdrop-filter: blur(...)`)。
        *   滑动开关的视觉样式和动画 (`.switch`, `.slider`, `:checked` 伪类)。
        *   按钮和开关的辉光效果 (`box-shadow` 应用于 `:hover` 或 `:focus` 状态)。
        *   过渡动画 (`transition`) 使效果更平滑。
        *   响应式设计的基本考虑 (`max-width`, `width: 95%`)。
    *   **JavaScript:** 处理用户交互，提升体验。
        *   **文件选择/拖拽:** 监听 `drop`, `dragover` 等事件实现文件拖拽上传。监听 `<input type="file">` 的 `change` 事件处理点击选择。
        *   **文件校验:** 基础的客户端文件类型检查 (仅 `.txt`)。
        *   **UI 更新:** 在选择/拖拽文件后，使用 JS 更新界面显示文件名 (`#file-info`)，并根据文件是否有效来**启用/禁用**提交按钮 (`submitBtn.disabled`)。
        *   **文件关联:** 使用 `DataTransfer` 对象将用户选择或拖拽的文件**关联**到隐藏的 `<input type="file">` 元素上，确保表单提交时文件能被发送到后端。
        *   **标签点击:** 使开关旁边的文字标签也能触发开关状态的改变。
